{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#projects-overview","title":"Project's overview","text":"<p>This repository documents my process of trying a reverse-engineering of the database schema and key tables in WhatsApp's SQLite databases.</p> <p>It also includes some SQL queries to automate data extraction and analysis, shedding light on how you can reconstruct humanly-readable information from these files.</p> <p>These are files you can access with all kinds of file manager application on your Android device after launching a backup via the application's settings menu. For the most part, you don't even need root access on your phone to reach for those.</p> <p>Proceed to Getting started to begin the journey.</p>"},{"location":"#validity","title":"Validity","text":"<p>The information you find here are surely valid for WhatsApp's versions ranging from 2.23.XX.XX to 2.24.19.86.</p> <p>I also expect this to still be useful for researching and analyzing instances of older versions with minimal modifications.</p> <p>As this has been an individual project, I had to rely on versions I personally used and therefore had the possibility to test for.</p>"},{"location":"#motivations","title":"Motivations","text":"<p>The primary goal of this project is to grant users the possibility to freely access messages they exchanged and data they generated through the app, circumventing some annoying limitations the application had since a long time.</p> <p>WhatsApp's application does indeed offer an \"Export Chat\" feature, but that forces you to accept some constraints you can read in their FAQ page, mainly:</p> <ol> <li>The application enables you to export a chat in a (rather ugly) <code>.txt</code> file, but if you choose to include media in the export, only the most recent media sent will be added as attachments to be sent from your sharesheet.</li> <li>When exporting with media or without media, you can only get up to 100,000 latest messages to be exported.</li> </ol> <p>The only other way to review some older messages would be to rely on WhatsApp's internal mechanism of handling backups and restores. That involves, in most cases, trusting a major cloud service for storing your backups, and be willing to start a recovery process that can only be triggered by deleting the application entirely and re-installing it. They do not handle different versions of the backup, so if the application produces a corrupted file, you will end up with nothing being restored (it actually happened to me). Finally, you can only do it that many times, since repeating the phone number verification process (you are asked for that during the initial setup of a freshly installed instance of the app) within limited time periods could flag you as a potentially malicious user, locking you out of your account for a day or so.</p> <p>The methodology I describe and the tool I'm developing enable you to recover all of your conversations and media files, as well as navigate the database in an interactive way.</p>"},{"location":"#ethical-considerations","title":"Ethical considerations","text":"<p>This project is strictly intended for educational and research purposes. I want to state clear that I'm not providing you any kind of way to access other people's data or breaking the encryption.</p> <p>If you do not have the encryption key (which is a 64-digits hexstring in the versions referenced here), you would have no way to access the plain messages.</p> <p>If you do happen to know the encryption key and you have access to the necessary files, you clearly have full access of the device WhatsApp is running on already, therefore, this project is not helping you further.</p>"},{"location":"Answers%20to%20messages/","title":"Answers to messages","text":"<p>[WIP]</p>"},{"location":"Calls/","title":"Calls","text":"<p>[WIP]</p>"},{"location":"Chats%20and%20Groups/","title":"Chats and Groups","text":"<p>To proceed to a full recovery and exploration of the chat history by means of analyzing the <code>msgstore</code> file, we firstly need to understand how to distinguish between group chats and one-to-one conversations.</p>"},{"location":"Chats%20and%20Groups/#key-tables-and-relations","title":"Key tables and relations","text":"<ul> <li><code>chat</code>: this table contains information about the various conversations you had, both groups and one-to-one chats (even hidden ones). In case of a group, it will also contain the group name (or subject), while it won't directly include the phone number in case of a single conversation, but it will help us to get that information.<ul> <li>important columns for this query: <code>_id</code>, <code>jid_row_id</code>, <code>subject</code>, <code>hidden</code></li> </ul> </li> <li><code>jid</code>: this table contains a record for each entity that can act in a WhatsApp system and associates an identifying string called jid to each entity.<ul> <li>By entity I mean both users and groups, but users are further specified by their device. In fact, if you change your device (or, I believe, just uninstall and re-install WhatsApp at some point) other people's WhatsApp systems will see you as a different entity (maybe because your end-to-end encryption key changes). </li> <li>the <code>user</code> field stores phone numbers.</li> <li>important columns for this query: <code>_id</code>, <code>user</code>, <code>type</code>, <code>raw_string</code></li> </ul> </li> </ul> <p>Additional notes</p> <ul> <li>the column of <code>jid</code> called <code>raw_string</code> is a combination of its other columns and is the identifying string for the entity referenced in that record.</li> <li>each <code>raw_string</code> is composed as <code>&lt;user&gt;.&lt;agent&gt;:&lt;device&gt;@&lt;server&gt;</code><ul> <li>if <code>device</code> is <code>0</code>, then it's just <code>&lt;user&gt;@&lt;server&gt;</code></li> <li><code>user</code> is the phone number in case of a 1-to-1 chat, and it's composed as <code>&lt;phone number of the group creator&gt;-&lt;timestamp of group creation&gt;</code> in the case of a group</li> <li>I don't know what <code>agent</code> is, but it seems to always have value <code>0</code> except for those records that have <code>server</code> equal to <code>lid</code> (I don't know what these are either, but I'm confident enough that these are neither users or groups).</li> <li><code>server</code> is equal to <code>g.us</code> for groups and to <code>s.whatsapp.net</code> for single users, but other values do exist that I still don't know how to use: <code>broadcast</code>, <code>newsletter</code>, <code>lid</code>, <code>lid_me</code>, <code>temp</code>, <code>status_me</code>.</li> <li><code>device</code> identifies the current device (I believe it's better to talk about the current app installation) the specific user is running on.</li> </ul> </li> <li><code>type</code> in <code>jid</code> can have many different values (they don't seem to be a contiguous range, as there are some values I never encountered), from <code>0</code> to <code>21</code>. <ul> <li>The only thing I came up with is that <code>0</code> means regular user, <code>1</code> means group.</li> </ul> </li> <li>the <code>chat</code> table only references <code>jid</code> records that have <code>device</code> equal to <code>0</code>.</li> <li>you will note that Channels are treated as normal Groups in the local database, so we don't have to discuss them further: you would just find each Topic of the Channel memorized as a different group in the various tables.</li> </ul>"},{"location":"Chats%20and%20Groups/#query","title":"Query","text":"<pre><code>CREATE VIEW AUX_conversation AS \nSELECT\n    chat._id AS id,\n    chat.hidden AS is_hidden,\n    jid._id AS recipient_jid_row_id,\n    jid.raw_string AS recipient_jid,\n    COALESCE(chat.subject, jid.user) AS displayed_name,\n    jid.type AS is_group\nFROM\n    chat JOIN jid ON chat.jid_row_id = jid._id\nWHERE jid.type = 0 OR jid.type = 1; -- discarding values of unknown meaning \n</code></pre> <p>We can now proceed to recover messages!</p>"},{"location":"Get%20messages%20from%20a%20conversation/","title":"Get messages from a conversation","text":"<p>The <code>message</code> table contains all messages that have been received or sent, to every possible chat, including messages that originated from WhatsApp systems (\"you blocked this contact\" or \"John Doe entered the group using the invite link\" kind of messages). Messages can be textual but they can also be any kind of media messages, so we need to be able to correctly distinguish them. Then we could, for example, query messages from a particular conversation.</p>"},{"location":"Get%20messages%20from%20a%20conversation/#key-tables-and-relations","title":"Key tables and relations","text":"<ul> <li><code>message</code>: this table contains all the data about a message you would think of; the ID of its sender, the ID of the conversation into which the message was exchanged, its type (text, image, video, voice note etc.), its read status (has it been read from the other party, just delivered to them, or just delivered to the server), if it is a starred message, the timestamps of when it was sent and when it was delivered.<ul> <li>important columns for this query: <code>_id</code>, <code>chat_row_id</code>, <code>from_me</code>, <code>sender_jid_row_id</code>, <code>timestamp</code>, <code>message_type</code>, <code>status</code>, <code>text_data</code></li> </ul> </li> <li><code>AUX_conversation</code> view we defined in Chats and Groups</li> <li><code>jid</code> table we already used in Chats and Groups<ul> <li>important columns for this query: <code>_id</code>, <code>user</code>, <code>raw_string</code></li> </ul> </li> </ul>"},{"location":"Get%20messages%20from%20a%20conversation/#auxiliary-tables","title":"Auxiliary tables","text":"<p>Since the <code>message_type</code> attribute of <code>message</code> table is an integer and we do not have meaningful information in the database about the association between each integer and its meaning as message type, I had to rely on my personal backups and check for known occurrences of messages of specific types in my chat history.  I've done a similar process for other tables as well. These kind of work has really been the central (and most time consuming) part of this reverse-engineering adventure. </p> <p>I ended up with enough (probably not all) associations. I think it's better to create a table out of these, as it will simplify future queries:</p> <pre><code>CREATE TABLE AUX_message_type (\n    id INTEGER PRIMARY KEY,\n    meaning TEXT NOT NULL\n);\nINSERT INTO AUX_message_type (id, meaning) VALUES (0, 'text');\nINSERT INTO AUX_message_type (id, meaning) VALUES (1, 'img');\nINSERT INTO AUX_message_type (id, meaning) VALUES (2, 'audio_or_voice_note');\nINSERT INTO AUX_message_type (id, meaning) VALUES (3, 'video');\nINSERT INTO AUX_message_type (id, meaning) VALUES (4, 'contact');\nINSERT INTO AUX_message_type (id, meaning) VALUES (5, 'location_static');\nINSERT INTO AUX_message_type (id, meaning) VALUES (7, 'system_message');\nINSERT INTO AUX_message_type (id, meaning) VALUES (9, 'document');\nINSERT INTO AUX_message_type (id, meaning) VALUES (13, 'gif');\nINSERT INTO AUX_message_type (id, meaning) VALUES (14, 'more_than_one_contact');\nINSERT INTO AUX_message_type (id, meaning) VALUES (15, 'voice_note'); -- duplicate?\nINSERT INTO AUX_message_type (id, meaning) VALUES (20, 'sticker');\nINSERT INTO AUX_message_type (id, meaning) VALUES (42, 'view_once_image');\nINSERT INTO AUX_message_type (id, meaning) VALUES (43, 'view_once_video');\nINSERT INTO AUX_message_type (id, meaning) VALUES (66, 'poll');\nINSERT INTO AUX_message_type (id, meaning) VALUES (90, '1to1_voice_call');\n</code></pre> <p>Same thing applies for the <code>status</code> column:</p> <pre><code>CREATE TABLE AUX_message_status (\n    id INTEGER PRIMARY KEY,\n    meaning TEXT NOT NULL\n);\nINSERT INTO AUX_message_status (id, meaning) VALUES (0, 'sent_by_them');\nINSERT INTO AUX_message_status (id, meaning) VALUES (13, 'read');\nINSERT INTO AUX_message_status (id, meaning) VALUES (5, 'received');\nINSERT INTO AUX_message_status (id, meaning) VALUES (4, 'sent');\nINSERT INTO AUX_message_status (id, meaning) VALUES (8, 'played');\n</code></pre>"},{"location":"Get%20messages%20from%20a%20conversation/#query","title":"Query","text":"<pre><code>SELECT \n    message._id AS id,\n    sender_jid.raw_string AS sender_jid,\n    sender_jid.user AS sender_phone,\n    message.timestamp AS sent_timestamp,\n    message.text_data AS text_contents,\n    COALESCE(\n        mstatus.meaning, \n        \"unknown: \" || cast(message.status AS text)\n    ) AS status, \n    COALESCE(\n        mtype.meaning, \n        \"unknown: \" || cast(message.message_type AS text)\n    ) AS type,\n    message.from_me AS is_from_me\nFROM \n    message\n    JOIN AUX_conversation chat_info\n        ON message.chat_row_id = chat_info.id\n    JOIN jid sender_jid\n        ON message.sender_jid_row_id = sender_jid._id\n    LEFT OUTER JOIN AUX_message_type mtype\n        ON message.message_type = mtype.id -- left outer to account for unknowns\n    LEFT OUTER JOIN AUX_message_status mstatus\n        ON message.status = mstatus.id -- left outer to account for unknowns\nWHERE chat_info.displayed_name = &lt;name&gt;;\n</code></pre> <p>Now that we understood how to get messages from a certain conversation, we are so interested in getting information about the attachments that the messages may have.</p>"},{"location":"Getting%20started/","title":"Getting started","text":"<p>In a rush?</p> <p>If you only care about what queries you have to run to extract your data, you can just refer to the Queries page, where you will find a bunch of. Also, if you are in such a rush, why not just use my tool?</p>"},{"location":"Getting%20started/#axioms","title":"Axioms","text":"<ul> <li>Since this project only aims to empower the user to recover their own messages and nothing more than that, I will frequently skip analyzing files, directories or SQL tables I don't find to be useful.</li> <li>This has been an individual project of mine for a year almost; I am basing this knowledge on different versions of WhatsApp and my own personal understanding of what the developers' choices were. So do expect something to not work as intended, or me openly saying I don't still have a clue of how something works.</li> <li>I will not analyze tables nor files that are clearly related to interactions with WhatsApp Business accounts or in-app payments.</li> <li>An instance of WhatsApp's application on an Android phone will mainly use two directories as storage for its data, one being protected by being access-restricted to normal system users because of Android's filesystem policies, and the other one fully accessible.<ul> <li>From now on we will refer to directory <code>/sdcard/Android/media/com.whatsapp</code> as the user data folder (fully accessible by any system user) and to directory <code>/sdcard/Android/data/com.whatsapp</code> as the application data folder (accessible only by privileged users).</li> </ul> </li> <li>From now on we will rely on the user having the possibility of decrypting its own local files, that is, on the user knowing what his decryption key is. Moreover, I will consider the user to have enabled the end-to-end encryption of the backup in WhatsApp's settings menu, that leads to all encrypted files having a <code>.crypt15</code> extension. Refer to How to get your decryption key for more details on that.</li> <li>Most of the files we are going to analyze are SQLite database files. <ul> <li>If you're not familiar with this DBMS or with SQL in general, I highly suggest you to get yourself a background before jumping into this. Moreover, I'll sometimes prefer showing you relations between tables and attributes by means of DBML diagrams instead of writing them down verbosely.</li> <li>To inspect these files and run queries on them I personally used DB Browser for SQLite, although I had all sorts of random crashes trying opening bigger databases from older backups (we're talking millions of messages). I ultimately moved to a VSCode extension called SQLite Viewer by Florian Klampfer that worked much better, even if I had to tweak some setting beforehand. </li> </ul> </li> </ul>"},{"location":"Getting%20started/#whatsapps-directory-structure-on-an-android-device","title":"WhatsApp's directory structure on an Android device","text":"<p>Exploring the user data folder we are presented with this file structure:</p> <pre><code>WhatsApp\n|\n+--- Backups/\n     |\n     +--- avatar-password.bkup.crypt15\n     +--- backup_settings.json.crypt15\n     +--- chatsettingsbackup.db.crypt15\n     +--- commerce_backup.db.crypt15\n     +--- stickers.db.crypt15\n     +--- wa.db.crypt15\n+--- Databases/\n     |\n     +--- msgstore.db.crypt15\n     +--- msgstore-&lt;date&gt;.db.crypt15\n     +--- msgstore-increment-&lt;incremental number&gt;.db.crypt15\n     +--- msgstore-increment-&lt;incremental number&gt;-&lt;date&gt;.db.crypt15\n+--- Media/\n     |\n     +--- WallPaper/\n     +--- WhatsApp Animated Gifs/\n     +--- WhatsApp Audio/\n     +--- WhatsApp Backup Excluded Stickers/\n     +--- WhatsApp Documents/\n     +--- WhatsApp Images/\n     +--- WhatsApp Sticker Packs/\n     +--- WhatsApp Stickers/\n     +--- WhatsApp Video/\n     +--- WhatsApp Video Notes/\n     +--- WhatsApp Voice Notes/\n</code></pre> <p>Some of these files are particularly useful to us. Let's analyze them:</p> <ul> <li>Files in the <code>Databases/</code> folder that do not include a date in their filename are files that got created in occasion of the lastly occurred triggering of the backup routine. Each time a new backup is process is launched, older files get renamed automatically to have appended their creation date.</li> <li>Messages you exchanged, as well as messages you received from WhatsApp's system (like messages about people joining or leaving groups you are a member of) are stored in <code>Databases/msgstore-...</code> files.<ul> <li>==<code>msgstore.db.cryptXX</code> is the main file you'd want to download on your PC for inspection. After decryption, it reveals itself to be a SQLite database storing all of your chat history.==</li> <li>even if they have <code>.db</code> extension, <code>-increment-</code> files are decrypted to <code>.zip</code> files, containing several <code>.json</code> files (that account for different modifications the database had since last backup was issued), apart from the <code>messages.bin</code> file, that actually contains data about messages exchanged in the day. I am not sure on what the encoding of this file is, but some information can be recovered by running <code>strings</code> on it.<ul> <li></li> </ul> </li> <li>Even if they can surely be of some interest, proceeding with the actual analysis of our data we will discard the <code>-increment-</code> files to only work with the <code>msgstore</code> file,  which contains the majority of the information we are interested in. Recovering the fragmented information from these files can be hard and lead to minimal additional results. Launching a backup manually will get you a <code>msgstore</code> file containing all the messages you exchanged until that moment anyway.</li> </ul> </li> </ul> <p>On the creation of <code>increment</code> files</p> <p>I'm not that sure about when <code>Databases/msgstore-increment...</code> are created, since they do not substitute <code>msgstore</code> files, which are bigger in size and still gets created every day if you enabled the daily backup routine. </p> <ul> <li>My best guess is that several <code>-increment-</code> files are created during periods between the triggering of backup creation routines. <ul> <li>For example, having set you backup routine to \"Daily\", you will find that during the day several of these files pop up in the folder, until the backup routine eventually gets launched (normally at 2:00 AM). </li> <li>When the time comes, information about what happened during the day will probably be reconstructed merging all of these <code>-increment-</code> files together and made into a new <code>msgstore</code> file, using the one from the previous day as baseline.</li> </ul> </li> </ul> <ul> <li>Getting into most of the files that are present in the <code>Backups/</code> folder is out of the scope of this project, so let's spend some words only on two of them in particular:<ul> <li><code>stickers.db.crypt15</code> does not contain information about the stickers other people sent to you, but about your own sticker packs. <ul> <li>after decryption, it's a <code>.zip</code> file containing:<ul> <li><code>.png</code> files for your sticker packs cover images, with sticker pack names as filenames</li> <li><code>.webp</code> files with alphanumerical (that seem base64 encoded, but actually decode to gibberish) filenames which are your actual stickers (including animated stickers)</li> <li>a SQLite database named <code>sticker.db</code>, containing useful information such as frequently used stickers, starred stickers and the belongings of each file to a specific stickers pack. <ul> <li>Check out Recovering your sticker packs to see what the database contains in more details.</li> </ul> </li> </ul> </li> </ul> </li> <li><code>wa.db.crypt15</code>: this is a file of particular interest to us because it contains information about your contacts. In particular, a table contained in this SQLite database contains the associations between the IDs of every user you chatted with their names, as they are recorded in your phone contacts application. It also contains their status phrases, some tables about blocked contacts, some statistics (like the total count of messages exchanged with that user/group) and so on.<ul> <li>However, there's a major problem to that: although this was the case some years ago, from a specific release of WhatsApp on, (we could date this with enough confidence in 2022: check out this conversation about the issue) this file contains all empty tables, and it seems like these information is not getting a local backup anymore. The encrypted file gets created anyway, but contents are stripped out beforehand.</li> <li>We can still recover information about the contacts we chatted with by using the <code>msgstore</code> file, along with any other file that links phone numbers with names: for instance, the CSV export of your own Google Contacts application. Check out Recovering contacts from wa.db to know more about that.</li> </ul> </li> </ul> </li> </ul> <p>We will now move on to the actual analysis of the msgstore file, which will get us to the core part of this project: recovering messages and their attachments, and associating them with the conversation they belong to, as well as to the sender.</p>"},{"location":"How%20to%20get%20your%20decryption%20key/","title":"How to get your decryption key","text":"<p>[WIP]</p>"},{"location":"Launching%20a%20backup%20manually/","title":"Launching a backup manually","text":"<p>[WIP]</p>"},{"location":"Locations/","title":"Locations","text":"<p>[WIP]</p>"},{"location":"Media%20attachments/","title":"Media attachments","text":"<p>Let's recall where the media files get saved in our device and how the directories are structured:</p> <pre><code>(user data folder)\n|\n+--- WhatsApp\n     |\n     +--- Media/\n          |\n          +--- WallPaper/\n          +--- WhatsApp Animated Gifs/\n          +--- WhatsApp Audio/\n          +--- WhatsApp Backup Excluded Stickers/\n          +--- WhatsApp Documents/\n          +--- WhatsApp Images/\n          +--- WhatsApp Sticker Packs/\n          +--- WhatsApp Stickers/\n          +--- WhatsApp Video/\n          +--- WhatsApp Video Notes/\n          +--- WhatsApp Voice Notes/\n</code></pre> <p>Each media attachment gets saved in a particular directory according to its type, but these directories do not identify the chat the attachment was sent to. Moreover, medias have filenames like <code>IMG-20210806-WA0001.jpeg</code> - so filenames contain the date they were sent, but no information about who sent them and to which conversation.</p> <p>That means we cannot directly recover the association between a media file and its sender, or even between a media file and the conversation it was sent to, just by looking at the filename or into its metadata. Luckily, this piece of information can be recovered easily from the <code>msgstore</code>.</p> <p><code>message_media</code> is the key table for getting further information on attachments, especially in the case of media (images, videos, GIFs, voice notes and so on). The same table contains also files shared \"as documents\", so any kind of file you can share in a WhatsApp conversation.</p>"},{"location":"Media%20attachments/#other-kinds-of-attachments","title":"Other kinds of attachments","text":"<p>As you probably know, WhatsApp also supports some attachments that are not really connected to sharing physical files. You can, for example, share a static location or a dynamic location, or share a phone number as a \"contact attachment\". These can actually be considered \"special types of messages\". Data about them can be found in the <code>message</code> table itself o sometimes contained in specialized tables, like <code>message_location</code>. Polls are another special kind of message.  All of these have to be discussed separately. As an example, refer to Locations. </p>"},{"location":"Media%20attachments/#key-tables-and-relations","title":"Key tables and relations","text":"<ul> <li><code>message_media</code>: this table contains information about media attachments, like voice notes, images, videos etc. This table also contains data about the files themselves, like their MIME type and size (in bytes). The most crucial information for us, however, is just the file path, which enables us to associate the file as we pulled from our device.</li> <li><code>message</code>, to get information about special kinds of messages, like </li> <li><code>AUX_message_type</code> could come in handy.</li> </ul> <p>{: .center}</p>"},{"location":"Media%20attachments/#query","title":"Query","text":"<p>We have now covered most of what we need to read WhatsApp's SQLite database and extract our chat history, but there are a few more things we can discuss about, like messages you didn't receive from your peers, but from WhatsApp's system itself.</p>"},{"location":"Other%20kinds%20of%20attachments/","title":"Other kinds of attachments","text":"<p>[WIP]</p>"},{"location":"Polls/","title":"Polls","text":"<p>[WIP]</p>"},{"location":"Queries/","title":"Queries","text":""},{"location":"Queries/#auxiliaries","title":"Auxiliaries","text":"<pre><code>CREATE VIEW IF NOT EXISTS AUX_conversation AS \nSELECT\n    chat._id AS id,\n    chat.hidden AS is_hidden,\n    jid._id AS recipient_jid_row_id,\n    jid.raw_string AS recipient_jid,\n    COALESCE(chat.subject, jid.user) AS displayed_name,\n    jid.type AS is_group\nFROM\n    chat JOIN jid ON chat.jid_row_id = jid._id\nWHERE jid.type = 0 OR jid.type = 1; -- discarding values of unknown meaning \n\nCREATE TABLE IF NOT EXISTS AUX_message_type (\n    id INTEGER PRIMARY KEY,\n    meaning TEXT NOT NULL\n);\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (0, 'text');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (1, 'img');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (2, 'audio_or_voice_note');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (3, 'video');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (4, 'contact');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (5, 'location_static');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (7, 'system_message');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (9, 'document');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (13, 'gif');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (14, 'more_than_one_contact');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (15, 'voice_note'); -- duplicate?\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (20, 'sticker');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (42, 'view_once_image');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (43, 'view_once_video');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (66, 'poll');\nINSERT OR IGNORE INTO AUX_message_type (id, meaning) VALUES (90, '1to1_voice_call');\n\nCREATE TABLE IF NOT EXISTS AUX_message_status (\n    id INTEGER PRIMARY KEY,\n    meaning TEXT NOT NULL\n);\nINSERT OR IGNORE INTO AUX_message_status (id, meaning) VALUES (0, 'sent_by_them');\nINSERT OR IGNORE INTO AUX_message_status (id, meaning) VALUES (13, 'read');\nINSERT OR IGNORE INTO AUX_message_status (id, meaning) VALUES (5, 'received');\nINSERT OR IGNORE INTO AUX_message_status (id, meaning) VALUES (4, 'sent');\nINSERT OR IGNORE INTO AUX_message_status (id, meaning) VALUES (8, 'played');\n\nCREATE TABLE IF NOT EXISTS AUX_system_action_type (\n    id INTEGER PRIMARY KEY,\n    meaning TEXT NOT NULL\n);\n\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(1, \"group_changed_subject\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(4, \"group_someone_joined\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(5, \"group_someone_left\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(6, \"group_changed_photo\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(10, \"group_someone_changed_number\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(11, \"group_someone_created_group\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(12, \"group_someone_has_been_added\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(14, \"group_someone_has_been_removed\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(15, \"group_you_became_administrator\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(20, \"group_someone_joined_via_invitation\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(27, \"group_changed_description\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(46, \"business_announcement\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(58, \"blocked_contact\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(59, \"ephemeral\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(67, \"cryptography_init\");\n</code></pre>"},{"location":"Queries/#user-messages","title":"User messages","text":"<p>Parameters: <code>chat_name</code>.</p> <pre><code>SELECT \n    message._id AS id,\n    sender_jid.raw_string AS sender_jid,\n    sender_jid.user AS sender_phone,\n    message.timestamp AS sent_timestamp,\n    message.text_data AS text_contents,\n    COALESCE(\n        mstatus.meaning, \n        \"unknown: \" || cast(message.status AS text)\n    ) AS status, \n    COALESCE(\n        mtype.meaning, \n        \"unknown: \" || cast(message.message_type AS text)\n    ) AS type,\n    message.from_me AS is_from_me\nFROM \n    message\n    JOIN AUX_conversation chat_info\n        ON message.chat_row_id = chat_info.id\n    JOIN jid sender_jid\n        ON message.sender_jid_row_id = sender_jid._id\n    LEFT OUTER JOIN AUX_message_type mtype\n        ON message.message_type = mtype.id -- left outer to account for unknowns\n    LEFT OUTER JOIN AUX_message_status mstatus\n        ON message.status = mstatus.id -- left outer to account for unknowns\nWHERE chat_info.displayed_name = &lt;chat_name&gt;;\n</code></pre>"},{"location":"Queries/#system-messages","title":"System messages","text":"<p>Parameters: <code>chat_name</code>.</p> <pre><code>SELECT \n    msys.message_row_id AS id,\n    COALESCE(\n        atype.meaning, \n        \"unknown: \" || cast(msys.action_type AS text)\n    ) AS type,  \n    message.timestamp AS timestamp,\n    message.text_data AS text_contents,\n    msys_block.is_blocked AS is_blocked,\n    CASE\n        WHEN msys_value.old_data IS NOT NULL\n        THEN message.text_data\n        ELSE NULL\n    END AS new_chat_name,\n    msys_value.old_data AS old_chat_name,\n    msys_group.is_me_joined AS is_me_joined,\n    msys_ph.old_photo AS old_chat_propic,\n    msys_ph.new_photo AS new_chat_propic,\n    old_jid.user AS old_actor_phone,\n    new_jid.user AS new_actor_phone,\n    participant_jid.user AS actor_phone,\n    meph.setting_duration AS ephemeral_duration\nFROM \n    message_system msys\n\n    JOIN message\n        ON msys.message_row_id = message._id\n    JOIN AUX_conversation chat_info\n        ON chat_info.id = message.chat_row_id\n\n    LEFT OUTER JOIN AUX_system_action_type atype -- to account for missing ones\n        ON atype.id = msys.action_type\n\n    LEFT OUTER JOIN message_system_block_contact msys_block\n        ON msys.message_row_id = msys_block.message_row_id  \n\n    LEFT OUTER JOIN message_system_value_change msys_value\n        ON msys.message_row_id = msys_block.message_row_id  \n\n    LEFT OUTER JOIN message_system_group msys_group\n        ON msys.message_row_id = msys_group.message_row_id  \n\n    LEFT OUTER JOIN message_system_photo_change msys_ph\n        ON msys.message_row_id = msys_ph.message_row_id \n\n    LEFT OUTER JOIN message_system_number_change msys_phone\n        ON msys.message_row_id = msys_phone.message_row_id  \n    LEFT OUTER JOIN jid old_jid\n        ON old_jid._id = msys_phone.old_jid_row_id\n    LEFT OUTER JOIN jid new_jid\n        ON new_jid._id = msys_phone.new_jid_row_id\n\n    LEFT OUTER JOIN message_system_chat_participant msys_cp\n        ON msys.message_row_id = msys_cp.message_row_id\n    LEFT OUTER JOIN jid participant_jid\n        ON participant_jid._id = msys_cp.user_jid_row_id\n\n    LEFT OUTER JOIN message_ephemeral_setting meph\n        ON msys.message_row_id = meph.message_row_id\n\nWHERE \n    chat_info.displayed_name = &lt;chat_name&gt;;\n</code></pre>"},{"location":"Recovering%20contacts%20from%20Google%20Contacts/","title":"Recovering contacts from Google Contacts","text":"<p>[WIP]</p>"},{"location":"Recovering%20contacts%20from%20Google%20Contacts/#wadb","title":"<code>wa.db</code>","text":""},{"location":"Recovering%20contacts%20from%20Google%20Contacts/#retrieving-your-contacts-from-google-contacts","title":"Retrieving your contacts from Google Contacts","text":""},{"location":"Recovering%20contacts%20from%20wa.db/","title":"Recovering contacts from wa.db","text":"<p>[WIP]</p>"},{"location":"Recovering%20contacts%20from%20wa.db/#wadb","title":"<code>wa.db</code>","text":""},{"location":"Recovering%20contacts%20from%20wa.db/#retrieving-your-contacts-from-google-contacts","title":"Retrieving your contacts from Google Contacts","text":""},{"location":"Recovering%20your%20sticker%20packs/","title":"Recovering your sticker packs","text":"<p>[WIP]</p>"},{"location":"Statistics/","title":"Statistics","text":"<p>[WIP]</p>"},{"location":"System%20messages/","title":"System messages","text":"<p>System messages are messages that you have not sent or received by any of your peers, but are instead sent to you by WhatsApp's system itself. More often than not these get rendered on the conversation itself, like for messages announcing someone joining or leaving a group, or you blocking a contact. The (rather annoying) alerts that notify you of the end-to-end encryption of your conversations at the very start of a new chat also fall in this category.</p> <p></p> <p>This messages are still stored in the <code>message</code> table among all other interactions real users have, but you do find them also referenced in the <code>message_system</code> table, where the type of that messages gets specified.  A bunch of additional tables in the database contribute to the complete characterization of these kind of \"special\" messages.</p>"},{"location":"System%20messages/#key-tables-and-relations","title":"Key tables and relations","text":"<ul> <li><code>message_system</code>: a table of just two columns, which builds the relation between each system message and its type, here called action type.<ul> <li>important columns for this query: <code>message_row_id</code>, <code>action_type</code></li> </ul> </li> <li><code>message</code>: contains all messages, including system's; useful here since some system messages do have text contents and that is stored only here. We know already that system messages have <code>type = 7</code> in this table from our previous analysis.<ul> <li>we don't need to filter for <code>type = 7</code> anyway, we can just user an inner join with <code>message_system</code>.</li> <li>important columns for this query: <code>_id</code>, <code>text_data</code>, <code>timestamp</code>, <code>chat_row_id</code></li> </ul> </li> <li><code>jid</code>: contains a unique string for each entity interacting in your WhatsApp system. We need this table to identify people (or entities) involved in the actions described in the system message (eg. who has left the group).<ul> <li>important columns for this query: <code>_id</code>, <code>user</code></li> </ul> </li> <li><code>message_system_chat_participant</code>: this table is used for all kind of messages involving a (former) group participant as an actor (eg. someone has left the group, someone has joined it). Only two columns linking the system message to the user.<ul> <li>important columns for this query: <code>message_row_id</code>, <code>user_jid_row_id</code></li> </ul> </li> <li><code>message_system_number_change</code>: in the case of a system message announcing that a group participant has changed its phone number, this table would link that message to both the old and new jid (identifying string, stored in the <code>jid</code> table) of that user<ul> <li>important columns for this query: <code>message_row_id</code>, <code>old_jid_row_id</code>, <code>new_jid_row_id</code></li> </ul> </li> <li><code>message_system_block_contact</code>: links messages announcing that you blocked or unblocked an user to the actual action you took<ul> <li>important columns for this query: <code>message_row_id</code>, <code>is_blocked</code></li> </ul> </li> <li><code>message_system_value_change</code>: when someone changes the name/subject of a group, or you change the name of a contact of yours, a system message is created in the <code>messages</code> table and gets referenced in this table. This table stores the old value of the name that was displayed; <code>messages</code> stores the new value for it in its <code>text_data</code> column.<ul> <li>important columns for this query: <code>message_row_id</code>, <code>old_data</code></li> </ul> </li> <li><code>message_system_photo_change</code>: this table's records actually store plain thumbnails (in JPG format) inside their columns, one for the picture the group used to have as its propic, and one for the newly set one.<ul> <li>important columns for this query: <code>message_row_id</code>, <code>old_photo</code>, <code>new_photo</code></li> </ul> </li> <li><code>message_system_group</code>: each time someone (yourself included) joins a group (either via an invitation link or because an administrator puts them in) a new system message (respectively, with <code>action_type</code> equal to <code>4</code> or to <code>20</code>) gets created. This table makes it possible to know if the one who joined was me or not. It's just two columns.<ul> <li>you could think about not using this table at all and recover this information (was it me the one who joined the group or was it someone else?) from a JOIN between <code>message_system_group_participant</code> and <code>jid</code>, checking if the jid of the one joining the group is your own. <ul> <li>However, I found out that the <code>jid</code> table does not store your own jid in any different way from any other user's, so you would have to rely on other JOIN operations to get what your jid is. So it's better to just use the <code>message_system_group</code> table.</li> </ul> </li> <li>important columns for this query: <code>message_row_id</code>, <code>is_me_joined</code></li> </ul> </li> <li><code>message_ephemeral_setting</code> keeps track of the chat being set as ephemeral and of how many seconds the messages will be kept before disappearing. If that field is <code>0</code>, the ephemeral setting is been disabled.<ul> <li>important columns for this query: <code>message_row_id</code>, <code>setting_duration</code></li> </ul> </li> <li>joining with <code>AUX_conversation</code> (which we created here) lets us filter these messages by chat.</li> </ul> <p>Other tables</p> <p>I am aware that these are not the only tables called <code>message_system_&lt;something&gt;</code> and therefore that even more information could technically be extracted. I just don't grasp the meaning of many of them still. Moreover, I find the list above to be quite exhaustive in helping specifying system messages.</p>"},{"location":"System%20messages/#auxiliary-tables","title":"Auxiliary tables","text":"<p>Just as we did for other messages, we can simplify our queries by manually adding a static table to the database, containing only associations between the identifying integers for action types and their actual meaning. <pre><code>CREATE TABLE IF NOT EXISTS AUX_system_action_type (\n    id INTEGER PRIMARY KEY,\n    meaning TEXT NOT NULL\n);\n\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(1, \"group_changed_subject\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(4, \"group_someone_joined\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(5, \"group_someone_left\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(6, \"group_changed_photo\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(10, \"group_someone_changed_number\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(11, \"group_someone_created_group\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(12, \"group_someone_has_been_added\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(14, \"group_someone_has_been_removed\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(15, \"group_you_became_administrator\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(20, \"group_someone_joined_via_invitation\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(27, \"group_changed_description\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(46, \"business_announcement\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(58, \"blocked_contact\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(59, \"ephemeral\");\nINSERT OR IGNORE INTO AUX_system_action_type(id, meaning) VALUES(67, \"cryptography_init\");\n</code></pre></p>"},{"location":"System%20messages/#query","title":"Query","text":"<pre><code>SELECT \n    msys.message_row_id AS id,\n    COALESCE(\n        atype.meaning, \n        \"unknown: \" || cast(msys.action_type AS text)\n    ) AS type,  \n    message.timestamp AS timestamp,\n    message.text_data AS text_contents,\n    msys_block.is_blocked AS is_blocked,\n    CASE\n        WHEN msys_value.old_data IS NOT NULL\n        THEN message.text_data\n        ELSE NULL\n    END AS new_chat_name,\n    msys_value.old_data AS old_chat_name,\n    msys_group.is_me_joined AS is_me_joined,\n    msys_ph.old_photo AS old_chat_propic,\n    msys_ph.new_photo AS new_chat_propic,\n    old_jid.user AS old_actor_phone,\n    new_jid.user AS new_actor_phone,\n    participant_jid.user AS actor_phone,\n    meph.setting_duration AS ephemeral_duration\nFROM \n    message_system msys\n\n    JOIN message\n        ON msys.message_row_id = message._id\n    JOIN AUX_conversation chat_info\n        ON chat_info.id = message.chat_row_id\n\n    LEFT OUTER JOIN AUX_system_action_type atype -- to account for missing ones\n        ON atype.id = msys.action_type\n\n    LEFT OUTER JOIN message_system_block_contact msys_block\n        ON msys.message_row_id = msys_block.message_row_id  \n\n    LEFT OUTER JOIN message_system_value_change msys_value\n        ON msys.message_row_id = msys_block.message_row_id  \n\n    LEFT OUTER JOIN message_system_group msys_group\n        ON msys.message_row_id = msys_group.message_row_id  \n\n    LEFT OUTER JOIN message_system_photo_change msys_ph\n        ON msys.message_row_id = msys_ph.message_row_id \n\n    LEFT OUTER JOIN message_system_number_change msys_phone\n        ON msys.message_row_id = msys_phone.message_row_id  \n    LEFT OUTER JOIN jid old_jid\n        ON old_jid._id = msys_phone.old_jid_row_id\n    LEFT OUTER JOIN jid new_jid\n        ON new_jid._id = msys_phone.new_jid_row_id\n\n    LEFT OUTER JOIN message_system_chat_participant msys_cp\n        ON msys.message_row_id = msys_cp.message_row_id\n    LEFT OUTER JOIN jid participant_jid\n        ON participant_jid._id = msys_cp.user_jid_row_id\n\n    LEFT OUTER JOIN message_ephemeral_setting meph\n        ON msys.message_row_id = meph.message_row_id\n\nWHERE \n    chat_info.displayed_name = &lt;name&gt;;\n</code></pre> <p>You should now have a full understanding of how things are stored in WhatsApp's SQLite, so you can go run your personal queries or start building your own viewer. I have created my own, check it out!</p>"}]}